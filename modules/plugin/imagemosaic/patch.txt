Index: src/test/java/org/geotools/gce/imagemosaic/ImageMosaicReaderTest.java
===================================================================
--- src/test/java/org/geotools/gce/imagemosaic/ImageMosaicReaderTest.java	(revision 36560)
+++ src/test/java/org/geotools/gce/imagemosaic/ImageMosaicReaderTest.java	(working copy)
@@ -48,7 +48,6 @@
 import org.geotools.coverage.grid.GridGeometry2D;
 import org.geotools.coverage.grid.io.AbstractGridCoverage2DReader;
 import org.geotools.coverage.grid.io.AbstractGridFormat;
-import org.geotools.coverage.grid.io.DecimationPolicy;
 import org.geotools.coverage.grid.io.GridFormatFinder;
 import org.geotools.coverage.grid.io.OverviewPolicy;
 import org.geotools.coverage.grid.io.UnknownFormat;
@@ -56,12 +55,12 @@
 import org.geotools.geometry.GeneralEnvelope;
 import org.geotools.parameter.Parameter;
 import org.geotools.referencing.CRS;
-import org.geotools.resources.geometry.XRectangle2D;
 import org.geotools.test.TestData;
+import org.geotools.util.DateRange;
+import org.geotools.util.NumberRange;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.opengis.geometry.MismatchedDimensionException;
 import org.opengis.parameter.GeneralParameterValue;
@@ -278,17 +277,21 @@
 		
 		final String[] metadataNames = reader.getMetadataNames();
 		assertNotNull(metadataNames);
-		assertEquals(metadataNames.length,4);
+		assertEquals(metadataNames.length,10);
 		
 		assertEquals("true", reader.getMetadataValue("HAS_TIME_DOMAIN"));
 		final String timeMetadata = reader.getMetadataValue("TIME_DOMAIN");
 		assertNotNull(timeMetadata);
 		assertEquals(16,timeMetadata.split(",").length);
+		assertEquals(timeMetadata.split(",")[0],reader.getMetadataValue("TIME_DOMAIN_MINIMUM"));
+		assertEquals(timeMetadata.split(",")[15],reader.getMetadataValue("TIME_DOMAIN_MAXIMUM"));
 		
 		assertEquals("true", reader.getMetadataValue("HAS_ELEVATION_DOMAIN"));
 		final String elevationMetadata = reader.getMetadataValue("ELEVATION_DOMAIN");
 		assertNotNull(elevationMetadata);
 		assertEquals(2,elevationMetadata.split(",").length);
+	        assertEquals(elevationMetadata.split(",")[0],reader.getMetadataValue("ELEVATION_DOMAIN_MINIMUM"));
+	        assertEquals(elevationMetadata.split(",")[1],reader.getMetadataValue("ELEVATION_DOMAIN_MAXIMUM"));
 		
 		
 		// limit yourself to reading just a bit of it
@@ -306,21 +309,25 @@
 		final ParameterValue<List> time = ImageMosaicFormat.TIME.createValue();
 		final List<Date> timeValues= new ArrayList<Date>();
 		final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.sss'Z'");
-        sdf.setTimeZone(TimeZone.getTimeZone("GMT+0"));
+		sdf.setTimeZone(TimeZone.getTimeZone("GMT+0"));
 		Date date = sdf.parse("2008-10-20T14:00:00.000Z");
 		timeValues.add(date);
 		time.setValue(timeValues);
 		
-		final ParameterValue<List> elevation = AbstractGridFormat.ELEVATION.createValue();
-		elevation.setValue(Arrays.asList(10.0));
-		
-		
 		final ParameterValue<double[]> bkg = ImageMosaicFormat.BACKGROUND_VALUES.createValue();
 		bkg.setValue(new double[]{-9999.0});
 		
+		final ParameterValue<List> elevation = ImageMosaicFormat.ELEVATION.createValue();
+		elevation.setValue(Arrays.asList(10.0));
+	                
 		// Test the output coverage
-		final GridCoverage2D coverage = getCoverage(reader, new GeneralParameterValue[] {gg,time,bkg,elevation });
-		testCoverage(reader, new GeneralParameterValue[] {gg,time,bkg ,elevation}, "Time-Elevation Test", coverage);
+		checkCoverage(reader, new GeneralParameterValue[] {gg,time,bkg ,elevation}, "Time-Elevation Test");
+		
+                elevation.setValue(Arrays.asList(NumberRange.create(0.0,10.0)));
+        
+                // Test the output coverage
+                checkCoverage(reader, new GeneralParameterValue[] { gg, time, bkg, elevation },
+                        "Time-Elevation Test");
 	}	
 	
 	
@@ -374,9 +381,11 @@
 		
 		final String[] metadataNames = reader.getMetadataNames();
 		assertNotNull(metadataNames);
-		assertEquals(metadataNames.length,4);
+		assertEquals(metadataNames.length,10);
 		assertEquals("2004-01-01T00:00:00.000Z,2004-02-01T00:00:00.000Z,2004-03-01T00:00:00.000Z,2004-04-01T00:00:00.000Z,2004-05-01T00:00:00.000Z,2004-06-01T00:00:00.000Z,2004-07-01T00:00:00.000Z", reader.getMetadataValue(metadataNames[0]));
 		assertEquals("true", reader.getMetadataValue("HAS_TIME_DOMAIN"));
+		assertEquals("2004-01-01T00:00:00.000Z", reader.getMetadataValue("TIME_DOMAIN_MINIMUM"));
+		assertEquals("2004-07-01T00:00:00.000Z", reader.getMetadataValue("TIME_DOMAIN_MAXIMUM"));
 		// limit yourself to reading just a bit of it
 		final ParameterValue<GridGeometry2D> gg =  AbstractGridFormat.READ_GRIDGEOMETRY2D.createValue();
 		final GeneralEnvelope envelope = reader.getOriginalEnvelope();
@@ -393,7 +402,7 @@
 		final ParameterValue<String> tileSize = AbstractGridFormat.SUGGESTED_TILE_SIZE.createValue();
 		tileSize.setValue("128,128");
 		
-		// specify current time
+		// specify time
 		final ParameterValue<List> time = ImageMosaicFormat.TIME.createValue();
 		
 		final SimpleDateFormat formatD = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
@@ -404,6 +413,15 @@
 		// Test the output coverage
 		checkCoverage(reader, new GeneralParameterValue[] {gg,useJai ,tileSize,time}, "time test");
 		
+		// specify time range
+		// Test the output coverage
+                time.setValue(
+                        new ArrayList(){{
+                            add(new DateRange(formatD.parse("2004-01-01T00:00:00.000Z"), formatD.parse("2004-02-01T00:00:00.000Z")));
+                            }}
+                );		
+                checkCoverage(reader, new GeneralParameterValue[] {gg,useJai ,tileSize,time}, "time test");
+		
 	}	
 	
     /**
@@ -632,11 +650,6 @@
 		testCoverage(reader, values, title, coverage, rect);
 	}
 
-	private void testCoverage(final ImageMosaicReader reader,
-                GeneralParameterValue[] values, String title,
-                final GridCoverage2D coverage){
-	    testCoverage(reader, values, title, coverage, null);
-	}
 	
 	@SuppressWarnings("unchecked")
 	private void testCoverage(final ImageMosaicReader reader,
Index: src/main/java/org/geotools/gce/imagemosaic/ImageMosaicReader.java
===================================================================
--- src/main/java/org/geotools/gce/imagemosaic/ImageMosaicReader.java	(revision 36560)
+++ src/main/java/org/geotools/gce/imagemosaic/ImageMosaicReader.java	(working copy)
@@ -55,6 +55,9 @@
 import org.geotools.data.Query;
 import org.geotools.data.QueryCapabilities;
 import org.geotools.factory.Hints;
+import org.geotools.feature.visitor.FeatureCalc;
+import org.geotools.feature.visitor.MaxVisitor;
+import org.geotools.feature.visitor.MinVisitor;
 import org.geotools.feature.visitor.UniqueVisitor;
 import org.geotools.filter.SortByImpl;
 import org.geotools.gce.imagemosaic.catalog.GranuleCatalog;
@@ -716,110 +719,64 @@
 
 	@Override
 	public String[] getMetadataNames() {
-		final boolean hasTimeAttribute=timeAttribute!=null;
-		final boolean hasElevationAttribute=elevationAttribute!=null;
-		if(hasElevationAttribute||hasTimeAttribute)
-		{
-			final List<String> metadataNames= new ArrayList<String>();
-			metadataNames.add("TIME_DOMAIN");
-                        metadataNames.add("HAS_TIME_DOMAIN");
-                        metadataNames.add("ELEVATION_DOMAIN");			
-			metadataNames.add("HAS_ELEVATION_DOMAIN");
-			return metadataNames.toArray(new String[metadataNames.size()]);
-		}
-		return super.getMetadataNames();
+	    final String []parentNames = super.getMetadataNames();
+            final List<String> metadataNames = new ArrayList<String>();
+            metadataNames.add("TIME_DOMAIN");
+            metadataNames.add("HAS_TIME_DOMAIN");
+            metadataNames.add("TIME_DOMAIN_MINIMUM");
+            metadataNames.add("TIME_DOMAIN_MAXIMUM");
+            metadataNames.add("TIME_DOMAIN_RESOLUTION");
+            metadataNames.add("ELEVATION_DOMAIN");
+            metadataNames.add("TIME_DOMAIN_MINIMUM");
+            metadataNames.add("TIME_DOMAIN_MAXIMUM");
+            metadataNames.add("HAS_ELEVATION_DOMAIN");
+            metadataNames.add("ELEVATION_DOMAIN_RESOLUTION");
+            if(parentNames!=null)
+                metadataNames.addAll(Arrays.asList(parentNames));
+            return metadataNames.toArray(new String[metadataNames.size()]);
 	}
 
 	@Override
 	public String getMetadataValue(final String name) {
-	        if(name.equalsIgnoreCase("HAS_ELEVATION_DOMAIN"))
-	        return String.valueOf(elevationAttribute!=null);
+	    final String superValue=super.getMetadataValue(name);
+	    if(superValue!=null)
+	        return superValue;
 	    
-	       if(name.equalsIgnoreCase("HAS_TIME_DOMAIN"))
-	                return String.valueOf(timeAttribute!=null);
-	    
-		final boolean getTimeAttribute=(timeAttribute!=null&&name.equalsIgnoreCase("time_domain"));
-		final QueryCapabilities queryCapabilities = rasterManager.granuleCatalog.getQueryCapabilities();
-		boolean manualSort=false;
-		if(getTimeAttribute){
-			Query query;
-			try {
-				query = new Query(rasterManager.granuleCatalog.getType().getTypeName());
-				query.setPropertyNames(Arrays.asList(timeAttribute));
-				final SortBy[] sortBy=new SortBy[]{
-						new SortByImpl(
-								FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute),
-								SortOrder.ASCENDING
-						)};
-				// if the store does not support sorting we have to do it by hand
-				if (queryCapabilities.supportsSorting(sortBy)) {
-					query.setSortBy(sortBy);
-				} else {
-					manualSort=true;
-				}
-				final UniqueVisitor visitor= new UniqueVisitor(timeAttribute);
-				rasterManager.granuleCatalog.computeAggregateFunction(query, visitor);
-				
-				// check result
-				final ArrayList<Date> result= new ArrayList<Date>();
-				result.addAll(visitor.getUnique());
-				if(manualSort)
-				    Collections.sort(result);
-
-				if(result.size()<=0)
-					return null;				
-				final StringBuilder buff= new StringBuilder();
-				final SimpleDateFormat df= new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
-				df.setTimeZone(UTC_TZ);
-				for(Date date:result){
-					buff.append(df.format(date)).append("Z");//ZULU
-					buff.append(",");
-				}
-				return buff.substring(0,buff.length()-1).toString();
-			} catch (IOException e) {
-				if(LOGGER.isLoggable(Level.WARNING))
-					LOGGER.log(Level.WARNING,"Unable to parse attribute:"+name,e);
-			}
-			
-		}
-
-		final boolean getElevationAttribute=(elevationAttribute!=null&&name.equalsIgnoreCase("elevation_domain"));
-		if(getElevationAttribute){
-			Query query;
-			try {
-				query = new Query(rasterManager.granuleCatalog.getType().getTypeName());
-				query.setPropertyNames(Arrays.asList(elevationAttribute));
-				final SortBy[] sortBy=new SortBy[]{
-						new SortByImpl(
-								FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.elevationAttribute),
-								SortOrder.ASCENDING
-						)};
-				if(queryCapabilities.supportsSorting(sortBy))
-					query.setSortBy(sortBy);
-				else
-					manualSort=true;				
-				final UniqueVisitor visitor= new UniqueVisitor(elevationAttribute);
-				rasterManager.granuleCatalog.computeAggregateFunction(query, visitor);
-				
-				// check result
-				final Set<Double> result = manualSort?new TreeSet<Double>(visitor.getUnique()):visitor.getUnique();
-				if(result.size()<=0)
-					return null;
-				final StringBuilder buff= new StringBuilder();
-				for(Iterator<Double> it=result.iterator();it.hasNext();){
-					final double value= (Double) it.next();
-					buff.append(value);
-					if(it.hasNext())
-						buff.append(",");
-				}
-				return buff.toString();
-			} catch (IOException e) {
-				if(LOGGER.isLoggable(Level.WARNING))
-					LOGGER.log(Level.WARNING,"Unable to parse attribute:"+name,e);
-			}
-			
-		}
-		
+            if (name.equalsIgnoreCase("HAS_ELEVATION_DOMAIN"))
+                return String.valueOf(elevationAttribute != null);
+    
+            if (name.equalsIgnoreCase("HAS_TIME_DOMAIN"))
+                return String.valueOf(timeAttribute != null);
+    
+            if (name.equalsIgnoreCase("TIME_DOMAIN_RESOLUTION"))
+                return null;
+    
+            final boolean getTimeDomain = (timeAttribute != null && name.equalsIgnoreCase("time_domain"));
+            if (getTimeDomain) {
+                return extractTimeDomain();
+    
+            }
+    
+            final boolean getTimeExtrema = timeAttribute != null
+                    && (name.equalsIgnoreCase("time_domain_minimum") || name.equalsIgnoreCase("time_domain_maximum"));
+            if (getTimeExtrema) {
+                return extractTimeExtrema(name);
+    
+            }
+    
+            final boolean getElevationAttribute = (elevationAttribute != null && name.equalsIgnoreCase("elevation_domain"));
+            if (getElevationAttribute) {
+                return extractElevationDomain();
+    
+            }
+    
+            final boolean getElevationExtrema = elevationAttribute != null
+                    && (name.equalsIgnoreCase("elevation_domain_minimum") || name.equalsIgnoreCase("elevation_domain_maximum"));
+            if (getElevationExtrema) {
+                return extractElevationExtrema(name);
+    
+            }
+        		
 //		final boolean getRuntimeAttribute=name.equalsIgnoreCase("runtime_domain");
 //		if(getRuntimeAttribute){
 //			Query query;
@@ -870,4 +827,176 @@
 //		
 		return super.getMetadataValue(name);
 	}
+
+
+    /**
+     * Extract the time domain extrema.
+     * 
+     * @param metadataName a {@link String} either TIME_DOMAIN_MAXIMUM or TIME_DOMAIN_MINIMUM.
+     * 
+     * @return either TIME_DOMAIN_MAXIMUM or TIME_DOMAIN_MINIMUM as a {@link String}.
+     */
+    private String extractTimeExtrema(String metadataName) {
+        if(timeAttribute==null){
+            if(LOGGER.isLoggable(Level.INFO))
+                LOGGER.info("Requesting extrema on attribute "+metadataName+" when no such an attribute is supported!");
+            return null;
+        }
+        try {
+            final FeatureCalc visitor = createExtremaQuery(metadataName,rasterManager.timeAttribute);
+            
+            // check result
+            final Date result=(Date) visitor.getResult().getValue();
+            final SimpleDateFormat df= new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
+            df.setTimeZone(UTC_TZ);
+            return df.format(result)+"Z";//ZULU
+        } catch (IOException e) {
+            if(LOGGER.isLoggable(Level.WARNING))
+                    LOGGER.log(Level.WARNING,"Unable to compute extrema for TIME_DOMAIN",e);
+            return null;
+        }
+    }
+
+    /**
+     * @param metadataName
+     * @param attributeName 
+     * @return
+     * @throws IOException
+     */
+    private FeatureCalc createExtremaQuery(String metadataName, String attributeName) throws IOException {
+        final Query query = new Query(rasterManager.granuleCatalog.getType().getTypeName());
+        query.setPropertyNames(Arrays.asList(attributeName));
+                              
+        final FeatureCalc visitor= 
+            metadataName.toLowerCase().endsWith("maximum")?
+                new MaxVisitor(attributeName):new MinVisitor(attributeName);
+        rasterManager.granuleCatalog.computeAggregateFunction(query, visitor);
+        return visitor;
+    }
+    
+    /**
+     * Extract the elevation domain extrema.
+     * 
+     * @param metadataName a {@link String} either ELEVATION_DOMAIN_MAXIMUM or ELEVATION_DOMAIN_MINIMUM.
+     * 
+     * @return either ELEVATION_DOMAIN_MAXIMUM or ELEVATION_DOMAIN_MINIMUM as a {@link String}.
+     */
+    private String extractElevationExtrema(String metadataName) {
+        if(elevationAttribute==null){
+            if(LOGGER.isLoggable(Level.INFO))
+                LOGGER.info("Requesting extrema on attribute "+metadataName+" when no such an attribute is supported!");
+            return null;
+        }
+        try {
+            final FeatureCalc visitor = createExtremaQuery(metadataName,rasterManager.elevationAttribute);
+            
+            // check result
+            final Double result=(Double) visitor.getResult().getValue();
+            return Double.toString(result);
+        } catch (IOException e) {
+            if(LOGGER.isLoggable(Level.WARNING))
+                    LOGGER.log(Level.WARNING,"Unable to compute extrema for ELEVATION_DOMAIN",e);
+            return null;
+        }
+    }
+
+    /**
+     * Extract the elevation domain as a comma separated list of string values.
+     * @return a {@link String} that contains a comma separated list of values.
+     */
+    private String extractElevationDomain() {
+        if(elevationAttribute==null){
+            if(LOGGER.isLoggable(Level.INFO))
+                LOGGER.info("Requesting domain on attribute elevation when no such an attribute is supported!");
+            return null;
+        }
+        try {
+            final Set<Double> result = extractDomain(elevationAttribute);          
+            // check result
+            if(result.size()<=0)
+                    return null;
+            
+            final StringBuilder buff= new StringBuilder();
+            for(Iterator<Double> it=result.iterator();it.hasNext();){
+                    final double value= (Double) it.next();
+                    buff.append(value);
+                    if(it.hasNext())
+                    	buff.append(",");
+            }
+            return buff.toString();
+        } catch (IOException e) {
+            if(LOGGER.isLoggable(Level.WARNING))
+                    LOGGER.log(Level.WARNING,"Unable to parse attribute: ELEVATION_DOMAIN",e);
+            return null;
+        }
+    }
+
+    /**
+     * Extract the domain of a dimension as a set of unique values.
+     * 
+     * <p>
+     * It retrieves a comma separated list of values as a {@link String}.
+     * 
+     * @return a comma separated list of values as a {@link String}.
+     * @throws IOException
+     */
+    private Set extractDomain(final String attribute)
+            throws IOException {
+
+        final QueryCapabilities queryCapabilities = rasterManager.granuleCatalog.getQueryCapabilities();
+        boolean manualSort=false;        
+        Query query = new Query(rasterManager.granuleCatalog.getType().getTypeName());
+        query.setPropertyNames(Arrays.asList(attribute));
+        final SortBy[] sortBy=new SortBy[]{
+                	new SortByImpl(
+                			FeatureUtilities.DEFAULT_FILTER_FACTORY.property(attribute),
+                			SortOrder.ASCENDING
+                	)};
+        if(queryCapabilities.supportsSorting(sortBy))
+                query.setSortBy(sortBy);
+        else
+                manualSort=true;				
+        final UniqueVisitor visitor= new UniqueVisitor(attribute);
+        rasterManager.granuleCatalog.computeAggregateFunction(query, visitor);
+        
+        // check result
+        final Set result = manualSort?
+                new TreeSet(visitor.getUnique()):
+                visitor.getUnique();
+        if(result.size()<=0)
+                return null;
+        return result;
+    }
+
+    /**
+     * Extract the elevation domain as a comma separated list of string values.
+     * @return a {@link String} that contains a comma separated list of values.
+     */
+    private String extractTimeDomain() {
+        if(timeAttribute==null){
+            if(LOGGER.isLoggable(Level.INFO))
+                LOGGER.info("Requesting domain on attribute time when no such an attribute is supported!");
+            return null;
+        }
+        try {
+            final Collection<Date>result =extractDomain(timeAttribute);
+            
+            // check result
+            if(result.size()<=0)
+                    return null;	
+                    
+            final StringBuilder buff= new StringBuilder();
+            final SimpleDateFormat df= new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
+            df.setTimeZone(UTC_TZ);
+            for(Date date:result){
+                    buff.append(df.format(date)).append("Z");//ZULU
+                    buff.append(",");
+            }
+            return buff.substring(0,buff.length()-1).toString();
+        } catch (IOException e) {
+            if(LOGGER.isLoggable(Level.WARNING))
+                    LOGGER.log(Level.WARNING,"Unable to parse attribute:"+"TIME_DOMAIN",e);
+            return null;
+        }
+    }
 }
Index: src/main/java/org/geotools/gce/imagemosaic/RasterLayerRequest.java
===================================================================
--- src/main/java/org/geotools/gce/imagemosaic/RasterLayerRequest.java	(revision 36560)
+++ src/main/java/org/geotools/gce/imagemosaic/RasterLayerRequest.java	(working copy)
@@ -20,7 +20,6 @@
 import java.awt.Dimension;
 import java.awt.Rectangle;
 import java.awt.geom.AffineTransform;
-import java.util.Date;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -149,13 +148,13 @@
 
 	private boolean multithreadingAllowed;
 
-	private List<Date> requestedTimes;
+	private List<?> requestedTimes;
 
-	private List<Double> elevation;
+	private List<?> elevation;
 	
 	private Filter filter = null;
 
-	public List<Double> getElevation() {
+	public List<?> getElevation() {
 		return elevation;
 	}
 
@@ -163,7 +162,7 @@
 		return filter;
 	}
 	
-	public List<Date> getRequestedTimes() {
+	public List<?> getRequestedTimes() {
 		return requestedTimes;
 	}
 
@@ -646,7 +645,7 @@
         	final Object value = param.getValue();
         	if(value==null)
         		return;
-            final List<Date> dates = (List<Date>) value;
+            final List<?> dates = (List<?>) value;
             if (dates==null|| dates.size()<=0) {
                 return;
             }
@@ -655,16 +654,16 @@
             return;
         }      
         
-        // //
+        // //x
         //
         // Elevation parameter
         //
         // //
-        if (name.equals(AbstractGridFormat.ELEVATION.getName())) {
+        if (name.equals(ImageMosaicFormat.ELEVATION.getName())) {
         	final Object value = param.getValue();
         	if(value==null)
         		return;
-            elevation = (List<Double>) value;
+            elevation = (List<?>) value;
             return;
         }            
 
Index: src/main/java/org/geotools/gce/imagemosaic/RasterLayerResponse.java
===================================================================
--- src/main/java/org/geotools/gce/imagemosaic/RasterLayerResponse.java	(revision 36560)
+++ src/main/java/org/geotools/gce/imagemosaic/RasterLayerResponse.java	(working copy)
@@ -31,7 +31,6 @@
 import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
 import java.util.concurrent.ExecutionException;
@@ -66,11 +65,9 @@
 import org.geotools.coverage.grid.GridGeometry2D;
 import org.geotools.data.DataSourceException;
 import org.geotools.data.Query;
-import org.geotools.data.QueryCapabilities;
 import org.geotools.factory.Hints;
 import org.geotools.feature.visitor.MaxVisitor;
 import org.geotools.filter.IllegalFilterException;
-import org.geotools.filter.SortByImpl;
 import org.geotools.gce.imagemosaic.OverviewsController.OverviewLevel;
 import org.geotools.gce.imagemosaic.catalog.GranuleCatalogVisitor;
 import org.geotools.geometry.Envelope2D;
@@ -86,7 +83,7 @@
 import org.geotools.resources.i18n.Vocabulary;
 import org.geotools.resources.i18n.VocabularyKeys;
 import org.geotools.resources.image.ImageUtilities;
-import org.geotools.util.Converters;
+import org.geotools.util.DateRange;
 import org.geotools.util.NumberRange;
 import org.geotools.util.SimpleInternationalString;
 import org.opengis.coverage.ColorInterpretation;
@@ -96,10 +93,7 @@
 import org.opengis.feature.Feature;
 import org.opengis.feature.simple.SimpleFeatureType;
 import org.opengis.filter.Filter;
-import org.opengis.filter.PropertyIsEqualTo;
 import org.opengis.filter.expression.Expression;
-import org.opengis.filter.sort.SortBy;
-import org.opengis.filter.sort.SortOrder;
 import org.opengis.geometry.BoundingBox;
 import org.opengis.referencing.datum.PixelInCell;
 import org.opengis.referencing.operation.MathTransform;
@@ -414,7 +408,7 @@
 				final RenderedImage loadedImage;
 				final GranuleLoadingResult result;
 				try {
-					if(!multithreadingAllowed)
+					if(!multithreadingAllowed|| rasterManager.parent.multiThreadedLoader == null)
 					{
 						//run the loading in this thread
 					    final FutureTask<GranuleLoadingResult> task=(FutureTask<GranuleLoadingResult>) future;
@@ -825,9 +819,9 @@
 			rasterBounds=tempRasterBounds.toRectangle2D().getBounds();
 			
 			
-			// SG using the above may lead to problems since the reason is that  may be a little (1 px) bigger
-			// than what we need. The code below is a bit better since it uses a proper logic (see GridEnvelope
-			// Javadoc)
+//			 SG using the above may lead to problems since the reason is that  may be a little (1 px) bigger
+//			 than what we need. The code below is a bit better since it uses a proper logic (see GridEnvelope
+//			 Javadoc)
 //			rasterBounds = new GridEnvelope2D(new Envelope2D(tempRasterBounds), PixelInCell.CELL_CORNER);
 			if (rasterBounds.width == 0)
 			    rasterBounds.width++;
@@ -844,8 +838,8 @@
 			// create the index visitor and visit the feature
 			final MosaicBuilder visitor = new MosaicBuilder();
 			visitor.request = request;
-			final List<Date> times = request.getRequestedTimes();
-			final List<Double> elevations=request.getElevation();
+			final List times = request.getRequestedTimes();
+			final List elevations=request.getElevation();
 			final Filter filter = request.getFilter();
 			final boolean hasTime=(times!=null&&times.size()>0);
 			final boolean hasElevation=(elevations!=null && elevations.size()>0);
@@ -858,74 +852,100 @@
 			    final Filter bbox=FeatureUtilities.DEFAULT_FILTER_FACTORY.bbox(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.granuleCatalog.getType().getGeometryDescriptor().getName()),mosaicBBox);
 			    query.setFilter( bbox);
 			}
-			
-			if(hasTime||hasElevation||hasFilter )
-			{
-				//handle elevation indexing first since we then combine this with the max in case we are asking for current in time
-				if (hasElevation){
-					
-					final Filter oldFilter = query.getFilter();
-					final PropertyIsEqualTo elevationF = 
-						FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(
-								FeatureUtilities.DEFAULT_FILTER_FACTORY.property(
-										rasterManager.elevationAttribute), 
-										FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(elevations.get(0)),
-										true
-						);
-					query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(oldFilter, elevationF));	
-				}
 
-				//handle runtime indexing since we then combine this with the max in case we are asking for current in time
-				if (hasFilter){
-					final Filter oldFilter = query.getFilter();
-					query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(oldFilter, filter));	
-				}
-				
-				// fuse time query with the bbox query
-				if(hasTime){
-					final Filter oldFilter = query.getFilter();
-					final int size=times.size();
-					boolean current= size==1&&times.get(0)==null;
-					if( !current){
-						Filter temporal=null;
-						if(size==1)
-							temporal=FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(times.get(0)),true);
-						else{
-							boolean first =true;
-							for( Date datetime: times){
-								if(first){
-									temporal=FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(datetime),true);
-									first =false;
-								}
-								else{
-									final PropertyIsEqualTo temp =
-										FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(datetime),true);
-									temporal= FeatureUtilities.DEFAULT_FILTER_FACTORY.or(Arrays.asList(temporal,temp));
-								}
-							}
-						}
-						if(temporal!=null)//should not happen
-							query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(oldFilter, temporal));
-					}
-					else{
-						// current management
-					        final MaxVisitor max = new MaxVisitor(rasterManager.timeAttribute);
-					        rasterManager.granuleCatalog.computeAggregateFunction(query,max);
-					        final Object result=max.getResult().getValue();
+                        if(hasTime||hasElevation||hasFilter )
+                        {
+                                //handle elevation indexing first since we then combine this with the max in case we are asking for current in time
+                                if (hasElevation){
+                                        
+                                        final List<Filter> elevationF=new ArrayList<Filter>();
+                                        for( Object elevation: elevations){
+                                            if(elevation==null){
+                                                if(LOGGER.isLoggable(Level.INFO))
+                                                    LOGGER.info("Ignoring null elevation for the elevation filter");
+                                                continue;
+                                            }
+                                            if(elevation instanceof Number){
+                                                elevationF.add( FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(
+                                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.elevationAttribute), 
+                                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(elevation),
+                                                    true)); 
+                                            } else {
+                                                // convert to range and create a correct range filter
+                                                @SuppressWarnings("rawtypes")
+                                                final NumberRange range= (NumberRange)elevation;
+                                                elevationF.add( 
+                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.and(
+                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.lessOrEqual(
+                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.elevationAttribute), 
+                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(range.getMaximum())),
+                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.greaterOrEqual(
+                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.elevationAttribute), 
+                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(range.getMinimum()))
+                                                        )); 
+                                            }
+                                            
+                                        }
+                                        final int elevationSize=elevationF.size();
+                                        if(elevationSize>1)//should not happen
+                                            query.setFilter(
+                                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.and(query.getFilter(),
+                                                            FeatureUtilities.DEFAULT_FILTER_FACTORY.or(elevationF))
+                                                            );  
+                                        else
+                                            if(elevationSize==1)
+                                                query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(query.getFilter(), elevationF.get(0)));        
+                                }
 
-					        // now let's get this feature by is fid
-						final Filter temporal = FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(Converters.convert(result, Date.class)),true);
-						query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(oldFilter, temporal));
-						
-						
-					}
-				}
-				
-				rasterManager.getGranules(query, visitor);
+                                //handle generic filter since we then combine this with the max in case we are asking for current in time
+                                if (hasFilter){
+                                        query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(query.getFilter(), filter));        
+                                }
+                                
+                                // fuse time query with the bbox query
+                                if(hasTime){
+                                        final List<Filter> timeFilter=new ArrayList<Filter>();
+                                        for( Object datetime: times){
+                                            if(datetime==null){
+                                                if(LOGGER.isLoggable(Level.INFO))
+                                                    LOGGER.info("Ignoring null date for the time filter");
+                                                continue;
+                                            }
+                                            if(datetime instanceof Date){
+                                                timeFilter.add(
+                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(
+                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), 
+                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(datetime),true));
+                                            }else {
+                                                // convert to range and create a correct range filter
+                                                final DateRange range= (DateRange)datetime;
+                                                timeFilter.add( 
+                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.and(
+                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.lessOrEqual(
+                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), 
+                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(range.getMaxValue())),
+                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.greaterOrEqual(
+                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), 
+                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(range.getMinValue()))
+                                                        )); 
+                                            }                                                
 
-			} else {
-			    rasterManager.getGranules(mosaicBBox, visitor);    
-			}
+                                        }
+                                        final int sizeTime=timeFilter.size();
+                                        if(sizeTime>1)//should not happen
+                                            query.setFilter(
+                                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.and(
+                                                            query.getFilter(), FeatureUtilities.DEFAULT_FILTER_FACTORY.or(timeFilter)));
+                                        else
+                                            if(sizeTime==1)
+                                                query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(query.getFilter(), timeFilter.get(0)));
+                                }
+                                
+                                rasterManager.getGranules(query, visitor);
+
+                        } else {
+                            rasterManager.getGranules(mosaicBBox, visitor);    
+                        }
 			// get those granules
 			visitor.produce();
 			
Index: src/main/java/org/geotools/gce/imagemosaic/ImageMosaicFormat.java
===================================================================
--- src/main/java/org/geotools/gce/imagemosaic/ImageMosaicFormat.java	(revision 36560)
+++ src/main/java/org/geotools/gce/imagemosaic/ImageMosaicFormat.java	(working copy)
@@ -106,8 +106,7 @@
     static final Interpolation DEFAULT_INTERPOLATION = new InterpolationNearest();
 
     /** Optional Time value for this mosaic. */
-    @SuppressWarnings("unchecked")
-	public static final ParameterDescriptor<List> TIME = DefaultParameterDescriptor.create("TIME", "A list of time objects",List.class, null,false);    
+    public static final ParameterDescriptor<List> TIME = DefaultParameterDescriptor.create("TIME", "A list of time objects",List.class, null,false);    
     
     /** Filter tiles based on attributes from the input coverage*/
     public static final ParameterDescriptor<Filter> FILTER = new DefaultParameterDescriptor<Filter>("Filter", Filter.class, null, null);
@@ -143,6 +142,9 @@
     public static final ParameterDescriptor<Interpolation> INTERPOLATION = new DefaultParameterDescriptor<Interpolation>(
             "Interpolation", Interpolation.class, null, DEFAULT_INTERPOLATION);
 
+    /** Optional Elevation value for this mosaic. */
+    public static final ParameterDescriptor<List> ELEVATION = DefaultParameterDescriptor.create("ELEVATION", "An elevation value",List.class, null,false);
+
     
     /**
      * Creates an instance and sets the metadata.
Index: src/main/java/org/geotools/gce/imagemosaic/GranuleDescriptor.java
===================================================================
--- src/main/java/org/geotools/gce/imagemosaic/GranuleDescriptor.java	(revision 36560)
+++ src/main/java/org/geotools/gce/imagemosaic/GranuleDescriptor.java	(working copy)
@@ -86,7 +86,7 @@
  * Right now we are making the assumption that a single granuleDescriptor is made a by a
  * single file with embedded overviews, either explicit or intrinsic through wavelets like MrSID,
  * ECW or JPEG2000.
- * 
+ *      
  * @author Simone Giannecchini, GeoSolutions S.A.S.
  * @author Stefan Alfons Krueger (alfonx), Wikisquare.de : Support for jar:file:foo.jar/bar.properties URLs
  * @since 2.5.5
